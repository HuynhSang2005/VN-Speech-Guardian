/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * VN Speech Guardian API
 * Speech-to-Text with toxicity detection for Vietnamese
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AuthControllerVerifyClerkTokenBody,
  CreateSessionDto,
  SessionCreateResponseDto,
  SessionListResponseDto,
  SessionResponseDto,
  SessionsControllerListParams,
  StatsOverviewResponseDto,
  TranscriptListResponseDto,
  UserSwaggerDto,
} from '../../schemas/generated'

import { customInstance } from '../../lib/api-client'
export type healthControllerHealthResponse200 = {
  data: null
  status: 200
}

export type healthControllerHealthResponseComposite = healthControllerHealthResponse200

export type healthControllerHealthResponse = healthControllerHealthResponseComposite & {
  headers: Headers
}

export const getHealthControllerHealthUrl = () => {
  return `http://localhost:3001/health`
}

export const healthControllerHealth = async (
  options?: RequestInit
): Promise<healthControllerHealthResponse> => {
  return customInstance<healthControllerHealthResponse>(getHealthControllerHealthUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getHealthControllerHealthQueryKey = () => {
  return [`http://localhost:3001/health`] as const
}

export const getHealthControllerHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof healthControllerHealth>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthControllerHealthQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerHealth>>> = ({ signal }) =>
    healthControllerHealth(signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type HealthControllerHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerHealth>>
>
export type HealthControllerHealthQueryError = unknown

export function useHealthControllerHealth<
  TData = Awaited<ReturnType<typeof healthControllerHealth>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerHealth>>,
          TError,
          Awaited<ReturnType<typeof healthControllerHealth>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthControllerHealth<
  TData = Awaited<ReturnType<typeof healthControllerHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerHealth>>,
          TError,
          Awaited<ReturnType<typeof healthControllerHealth>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthControllerHealth<
  TData = Awaited<ReturnType<typeof healthControllerHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthControllerHealth<
  TData = Awaited<ReturnType<typeof healthControllerHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealth>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthControllerHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export type healthControllerReadyResponse200 = {
  data: null
  status: 200
}

export type healthControllerReadyResponseComposite = healthControllerReadyResponse200

export type healthControllerReadyResponse = healthControllerReadyResponseComposite & {
  headers: Headers
}

export const getHealthControllerReadyUrl = () => {
  return `http://localhost:3001/ready`
}

export const healthControllerReady = async (
  options?: RequestInit
): Promise<healthControllerReadyResponse> => {
  return customInstance<healthControllerReadyResponse>(getHealthControllerReadyUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getHealthControllerReadyQueryKey = () => {
  return [`http://localhost:3001/ready`] as const
}

export const getHealthControllerReadyQueryOptions = <
  TData = Awaited<ReturnType<typeof healthControllerReady>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthControllerReadyQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerReady>>> = ({ signal }) =>
    healthControllerReady(signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type HealthControllerReadyQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerReady>>
>
export type HealthControllerReadyQueryError = unknown

export function useHealthControllerReady<
  TData = Awaited<ReturnType<typeof healthControllerReady>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerReady>>,
          TError,
          Awaited<ReturnType<typeof healthControllerReady>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthControllerReady<
  TData = Awaited<ReturnType<typeof healthControllerReady>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerReady>>,
          TError,
          Awaited<ReturnType<typeof healthControllerReady>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthControllerReady<
  TData = Awaited<ReturnType<typeof healthControllerReady>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthControllerReady<
  TData = Awaited<ReturnType<typeof healthControllerReady>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthControllerReady>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthControllerReadyQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export type metricsControllerMetricsResponse200 = {
  data: null
  status: 200
}

export type metricsControllerMetricsResponseComposite = metricsControllerMetricsResponse200

export type metricsControllerMetricsResponse = metricsControllerMetricsResponseComposite & {
  headers: Headers
}

export const getMetricsControllerMetricsUrl = () => {
  return `http://localhost:3001/metrics`
}

export const metricsControllerMetrics = async (
  options?: RequestInit
): Promise<metricsControllerMetricsResponse> => {
  return customInstance<metricsControllerMetricsResponse>(getMetricsControllerMetricsUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getMetricsControllerMetricsQueryKey = () => {
  return [`http://localhost:3001/metrics`] as const
}

export const getMetricsControllerMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof metricsControllerMetrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMetricsControllerMetricsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metricsControllerMetrics>>> = ({
    signal,
  }) => metricsControllerMetrics(signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type MetricsControllerMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metricsControllerMetrics>>
>
export type MetricsControllerMetricsQueryError = unknown

export function useMetricsControllerMetrics<
  TData = Awaited<ReturnType<typeof metricsControllerMetrics>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metricsControllerMetrics>>,
          TError,
          Awaited<ReturnType<typeof metricsControllerMetrics>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMetricsControllerMetrics<
  TData = Awaited<ReturnType<typeof metricsControllerMetrics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metricsControllerMetrics>>,
          TError,
          Awaited<ReturnType<typeof metricsControllerMetrics>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMetricsControllerMetrics<
  TData = Awaited<ReturnType<typeof metricsControllerMetrics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMetricsControllerMetrics<
  TData = Awaited<ReturnType<typeof metricsControllerMetrics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metricsControllerMetrics>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMetricsControllerMetricsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Send Clerk JWT either in request body or Authorization header. User will be created/synced in database.
 * @summary Verify Clerk token and sync user to database
 */
export type authControllerVerifyClerkTokenResponse200 = {
  data: UserSwaggerDto
  status: 200
}

export type authControllerVerifyClerkTokenResponse401 = {
  data: null
  status: 401
}

export type authControllerVerifyClerkTokenResponseComposite =
  | authControllerVerifyClerkTokenResponse200
  | authControllerVerifyClerkTokenResponse401

export type authControllerVerifyClerkTokenResponse =
  authControllerVerifyClerkTokenResponseComposite & {
    headers: Headers
  }

export const getAuthControllerVerifyClerkTokenUrl = () => {
  return `http://localhost:3001/api/auth/clerk`
}

export const authControllerVerifyClerkToken = async (
  authControllerVerifyClerkTokenBody: AuthControllerVerifyClerkTokenBody,
  options?: RequestInit
): Promise<authControllerVerifyClerkTokenResponse> => {
  return customInstance<authControllerVerifyClerkTokenResponse>(
    getAuthControllerVerifyClerkTokenUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(authControllerVerifyClerkTokenBody),
    }
  )
}

export const getAuthControllerVerifyClerkTokenMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerVerifyClerkToken>>,
    TError,
    { data: AuthControllerVerifyClerkTokenBody },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerVerifyClerkToken>>,
  TError,
  { data: AuthControllerVerifyClerkTokenBody },
  TContext
> => {
  const mutationKey = ['authControllerVerifyClerkToken']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerVerifyClerkToken>>,
    { data: AuthControllerVerifyClerkTokenBody }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerVerifyClerkToken(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AuthControllerVerifyClerkTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerVerifyClerkToken>>
>
export type AuthControllerVerifyClerkTokenMutationBody = AuthControllerVerifyClerkTokenBody
export type AuthControllerVerifyClerkTokenMutationError = null

/**
 * @summary Verify Clerk token and sync user to database
 */
export const useAuthControllerVerifyClerkToken = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerVerifyClerkToken>>,
      TError,
      { data: AuthControllerVerifyClerkTokenBody },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerVerifyClerkToken>>,
  TError,
  { data: AuthControllerVerifyClerkTokenBody },
  TContext
> => {
  const mutationOptions = getAuthControllerVerifyClerkTokenMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Returns current authenticated user information
 * @summary Get current user info
 */
export type authControllerGetCurrentUserResponse200 = {
  data: null
  status: 200
}

export type authControllerGetCurrentUserResponseComposite = authControllerGetCurrentUserResponse200

export type authControllerGetCurrentUserResponse = authControllerGetCurrentUserResponseComposite & {
  headers: Headers
}

export const getAuthControllerGetCurrentUserUrl = () => {
  return `http://localhost:3001/api/auth/me`
}

export const authControllerGetCurrentUser = async (
  options?: RequestInit
): Promise<authControllerGetCurrentUserResponse> => {
  return customInstance<authControllerGetCurrentUserResponse>(
    getAuthControllerGetCurrentUserUrl(),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getAuthControllerGetCurrentUserQueryKey = () => {
  return [`http://localhost:3001/api/auth/me`] as const
}

export const getAuthControllerGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuthControllerGetCurrentUserQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetCurrentUser>>> = ({
    signal,
  }) => authControllerGetCurrentUser(signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type AuthControllerGetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetCurrentUser>>
>
export type AuthControllerGetCurrentUserQueryError = unknown

export function useAuthControllerGetCurrentUser<
  TData = Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetCurrentUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetCurrentUser<
  TData = Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetCurrentUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetCurrentUser<
  TData = Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user info
 */

export function useAuthControllerGetCurrentUser<
  TData = Awaited<ReturnType<typeof authControllerGetCurrentUser>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authControllerGetCurrentUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new session
 */
export type sessionsControllerCreateResponse201 = {
  data: SessionCreateResponseDto
  status: 201
}

export type sessionsControllerCreateResponseComposite = sessionsControllerCreateResponse201

export type sessionsControllerCreateResponse = sessionsControllerCreateResponseComposite & {
  headers: Headers
}

export const getSessionsControllerCreateUrl = () => {
  return `http://localhost:3001/api/sessions`
}

export const sessionsControllerCreate = async (
  createSessionDto: CreateSessionDto,
  options?: RequestInit
): Promise<sessionsControllerCreateResponse> => {
  return customInstance<sessionsControllerCreateResponse>(getSessionsControllerCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createSessionDto),
  })
}

export const getSessionsControllerCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionsControllerCreate>>,
    TError,
    { data: CreateSessionDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionsControllerCreate>>,
  TError,
  { data: CreateSessionDto },
  TContext
> => {
  const mutationKey = ['sessionsControllerCreate']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionsControllerCreate>>,
    { data: CreateSessionDto }
  > = (props) => {
    const { data } = props ?? {}

    return sessionsControllerCreate(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionsControllerCreate>>
>
export type SessionsControllerCreateMutationBody = CreateSessionDto
export type SessionsControllerCreateMutationError = unknown

/**
 * @summary Create a new session
 */
export const useSessionsControllerCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionsControllerCreate>>,
      TError,
      { data: CreateSessionDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sessionsControllerCreate>>,
  TError,
  { data: CreateSessionDto },
  TContext
> => {
  const mutationOptions = getSessionsControllerCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List sessions (paged)
 */
export type sessionsControllerListResponse200 = {
  data: SessionListResponseDto
  status: 200
}

export type sessionsControllerListResponseComposite = sessionsControllerListResponse200

export type sessionsControllerListResponse = sessionsControllerListResponseComposite & {
  headers: Headers
}

export const getSessionsControllerListUrl = (params?: SessionsControllerListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `http://localhost:3001/api/sessions?${stringifiedParams}`
    : `http://localhost:3001/api/sessions`
}

export const sessionsControllerList = async (
  params?: SessionsControllerListParams,
  options?: RequestInit
): Promise<sessionsControllerListResponse> => {
  return customInstance<sessionsControllerListResponse>(getSessionsControllerListUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getSessionsControllerListQueryKey = (params?: SessionsControllerListParams) => {
  return [`http://localhost:3001/api/sessions`, ...(params ? [params] : [])] as const
}

export const getSessionsControllerListQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionsControllerList>>,
  TError = unknown,
>(
  params?: SessionsControllerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionsControllerListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionsControllerList>>> = ({ signal }) =>
    sessionsControllerList(params, signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type SessionsControllerListQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionsControllerList>>
>
export type SessionsControllerListQueryError = unknown

export function useSessionsControllerList<
  TData = Awaited<ReturnType<typeof sessionsControllerList>>,
  TError = unknown,
>(
  params: undefined | SessionsControllerListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerList>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerList>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerList<
  TData = Awaited<ReturnType<typeof sessionsControllerList>>,
  TError = unknown,
>(
  params?: SessionsControllerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerList>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerList>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerList<
  TData = Awaited<ReturnType<typeof sessionsControllerList>>,
  TError = unknown,
>(
  params?: SessionsControllerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List sessions (paged)
 */

export function useSessionsControllerList<
  TData = Awaited<ReturnType<typeof sessionsControllerList>>,
  TError = unknown,
>(
  params?: SessionsControllerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerList>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSessionsControllerListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get session detail
 */
export type sessionsControllerGetResponse200 = {
  data: SessionResponseDto
  status: 200
}

export type sessionsControllerGetResponse404 = {
  data: null
  status: 404
}

export type sessionsControllerGetResponseComposite =
  | sessionsControllerGetResponse200
  | sessionsControllerGetResponse404

export type sessionsControllerGetResponse = sessionsControllerGetResponseComposite & {
  headers: Headers
}

export const getSessionsControllerGetUrl = (id: string) => {
  return `http://localhost:3001/api/sessions/${id}`
}

export const sessionsControllerGet = async (
  id: string,
  options?: RequestInit
): Promise<sessionsControllerGetResponse> => {
  return customInstance<sessionsControllerGetResponse>(getSessionsControllerGetUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getSessionsControllerGetQueryKey = (id?: string) => {
  return [`http://localhost:3001/api/sessions/${id}`] as const
}

export const getSessionsControllerGetQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
  TError = null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionsControllerGetQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionsControllerGet>>> = ({ signal }) =>
    sessionsControllerGet(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type SessionsControllerGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionsControllerGet>>
>
export type SessionsControllerGetQueryError = null

export function useSessionsControllerGet<
  TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
  TError = null,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerGet>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerGet>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerGet<
  TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
  TError = null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerGet>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerGet>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerGet<
  TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
  TError = null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get session detail
 */

export function useSessionsControllerGet<
  TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
  TError = null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerGet>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSessionsControllerGetQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Delete a session
 */
export type sessionsControllerRemoveResponse200 = {
  data: null
  status: 200
}

export type sessionsControllerRemoveResponseComposite = sessionsControllerRemoveResponse200

export type sessionsControllerRemoveResponse = sessionsControllerRemoveResponseComposite & {
  headers: Headers
}

export const getSessionsControllerRemoveUrl = (id: string) => {
  return `http://localhost:3001/api/sessions/${id}`
}

export const sessionsControllerRemove = async (
  id: string,
  options?: RequestInit
): Promise<sessionsControllerRemoveResponse> => {
  return customInstance<sessionsControllerRemoveResponse>(getSessionsControllerRemoveUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getSessionsControllerRemoveMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionsControllerRemove>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['sessionsControllerRemove']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionsControllerRemove>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return sessionsControllerRemove(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionsControllerRemove>>
>

export type SessionsControllerRemoveMutationError = unknown

/**
 * @summary Delete a session
 */
export const useSessionsControllerRemove = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionsControllerRemove>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sessionsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getSessionsControllerRemoveMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List transcripts for a session
 */
export type sessionsControllerTranscriptsResponse200 = {
  data: TranscriptListResponseDto
  status: 200
}

export type sessionsControllerTranscriptsResponseComposite =
  sessionsControllerTranscriptsResponse200

export type sessionsControllerTranscriptsResponse =
  sessionsControllerTranscriptsResponseComposite & {
    headers: Headers
  }

export const getSessionsControllerTranscriptsUrl = (id: string) => {
  return `http://localhost:3001/api/sessions/${id}/transcripts`
}

export const sessionsControllerTranscripts = async (
  id: string,
  options?: RequestInit
): Promise<sessionsControllerTranscriptsResponse> => {
  return customInstance<sessionsControllerTranscriptsResponse>(
    getSessionsControllerTranscriptsUrl(id),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getSessionsControllerTranscriptsQueryKey = (id?: string) => {
  return [`http://localhost:3001/api/sessions/${id}/transcripts`] as const
}

export const getSessionsControllerTranscriptsQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionsControllerTranscriptsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionsControllerTranscripts>>> = ({
    signal,
  }) => sessionsControllerTranscripts(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type SessionsControllerTranscriptsQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionsControllerTranscripts>>
>
export type SessionsControllerTranscriptsQueryError = unknown

export function useSessionsControllerTranscripts<
  TData = Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerTranscripts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerTranscripts<
  TData = Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
          TError,
          Awaited<ReturnType<typeof sessionsControllerTranscripts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionsControllerTranscripts<
  TData = Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List transcripts for a session
 */

export function useSessionsControllerTranscripts<
  TData = Awaited<ReturnType<typeof sessionsControllerTranscripts>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionsControllerTranscripts>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSessionsControllerTranscriptsQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export type statsControllerOverviewResponse200 = {
  data: StatsOverviewResponseDto
  status: 200
}

export type statsControllerOverviewResponseComposite = statsControllerOverviewResponse200

export type statsControllerOverviewResponse = statsControllerOverviewResponseComposite & {
  headers: Headers
}

export const getStatsControllerOverviewUrl = () => {
  return `http://localhost:3001/api/stats/overview`
}

export const statsControllerOverview = async (
  options?: RequestInit
): Promise<statsControllerOverviewResponse> => {
  return customInstance<statsControllerOverviewResponse>(getStatsControllerOverviewUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getStatsControllerOverviewQueryKey = () => {
  return [`http://localhost:3001/api/stats/overview`] as const
}

export const getStatsControllerOverviewQueryOptions = <
  TData = Awaited<ReturnType<typeof statsControllerOverview>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStatsControllerOverviewQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof statsControllerOverview>>> = ({
    signal,
  }) => statsControllerOverview(signal)

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    gcTime: 300000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type StatsControllerOverviewQueryResult = NonNullable<
  Awaited<ReturnType<typeof statsControllerOverview>>
>
export type StatsControllerOverviewQueryError = unknown

export function useStatsControllerOverview<
  TData = Awaited<ReturnType<typeof statsControllerOverview>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsControllerOverview>>,
          TError,
          Awaited<ReturnType<typeof statsControllerOverview>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsControllerOverview<
  TData = Awaited<ReturnType<typeof statsControllerOverview>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsControllerOverview>>,
          TError,
          Awaited<ReturnType<typeof statsControllerOverview>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsControllerOverview<
  TData = Awaited<ReturnType<typeof statsControllerOverview>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsControllerOverview<
  TData = Awaited<ReturnType<typeof statsControllerOverview>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statsControllerOverview>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getStatsControllerOverviewQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
